package repository

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/e4t4g/URL_shortener_GB-/internal/app/repository.Repository -o ./repository_mock_test.go -n RepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, url *URLData) (up1 *URLData, err error)
	inspectFuncCreate   func(ctx context.Context, url *URLData)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mRepositoryMockCreate

	funcFindByID          func(ctx context.Context, id int) (up1 *URLData, err error)
	inspectFuncFindByID   func(ctx context.Context, id int)
	afterFindByIDCounter  uint64
	beforeFindByIDCounter uint64
	FindByIDMock          mRepositoryMockFindByID

	funcFindByToken          func(ctx context.Context, token string) (up1 *URLData, err error)
	inspectFuncFindByToken   func(ctx context.Context, token string)
	afterFindByTokenCounter  uint64
	beforeFindByTokenCounter uint64
	FindByTokenMock          mRepositoryMockFindByToken

	funcUpdateCounter          func(ctx context.Context, counter int64, shortURL string) (err error)
	inspectFuncUpdateCounter   func(ctx context.Context, counter int64, shortURL string)
	afterUpdateCounterCounter  uint64
	beforeUpdateCounterCounter uint64
	UpdateCounterMock          mRepositoryMockUpdateCounter
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*RepositoryMockCreateParams{}

	m.FindByIDMock = mRepositoryMockFindByID{mock: m}
	m.FindByIDMock.callArgs = []*RepositoryMockFindByIDParams{}

	m.FindByTokenMock = mRepositoryMockFindByToken{mock: m}
	m.FindByTokenMock.callArgs = []*RepositoryMockFindByTokenParams{}

	m.UpdateCounterMock = mRepositoryMockUpdateCounter{mock: m}
	m.UpdateCounterMock.callArgs = []*RepositoryMockUpdateCounterParams{}

	return m
}

type mRepositoryMockCreate struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateExpectation
	expectations       []*RepositoryMockCreateExpectation

	callArgs []*RepositoryMockCreateParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateExpectation specifies expectation struct of the Repository.Create
type RepositoryMockCreateExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateParams
	results *RepositoryMockCreateResults
	Counter uint64
}

// RepositoryMockCreateParams contains parameters of the Repository.Create
type RepositoryMockCreateParams struct {
	ctx context.Context
	url *URLData
}

// RepositoryMockCreateResults contains results of the Repository.Create
type RepositoryMockCreateResults struct {
	up1 *URLData
	err error
}

// Expect sets up expected params for Repository.Create
func (mmCreate *mRepositoryMockCreate) Expect(ctx context.Context, url *URLData) *mRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &RepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &RepositoryMockCreateParams{ctx, url}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Repository.Create
func (mmCreate *mRepositoryMockCreate) Inspect(f func(ctx context.Context, url *URLData)) *mRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Repository.Create
func (mmCreate *mRepositoryMockCreate) Return(up1 *URLData, err error) *RepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &RepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &RepositoryMockCreateResults{up1, err}
	return mmCreate.mock
}

//Set uses given function f to mock the Repository.Create method
func (mmCreate *mRepositoryMockCreate) Set(f func(ctx context.Context, url *URLData) (up1 *URLData, err error)) *RepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Repository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Repository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the Repository.Create which will trigger the stat defined by the following
// Then helper
func (mmCreate *mRepositoryMockCreate) When(ctx context.Context, url *URLData) *RepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	expectation := &RepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &RepositoryMockCreateParams{ctx, url},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Repository.Create return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateExpectation) Then(up1 *URLData, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateResults{up1, err}
	return e.mock
}

// Create implements Repository
func (mmCreate *RepositoryMock) Create(ctx context.Context, url *URLData) (up1 *URLData, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, url)
	}

	mm_params := &RepositoryMockCreateParams{ctx, url}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := RepositoryMockCreateParams{ctx, url}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("RepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the RepositoryMock.Create")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, url)
	}
	mmCreate.t.Fatalf("Unexpected call to RepositoryMock.Create. %v %v", ctx, url)
	return
}

// CreateAfterCounter returns a count of finished RepositoryMock.Create invocations
func (mmCreate *RepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of RepositoryMock.Create invocations
func (mmCreate *RepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mRepositoryMockCreate) Calls() []*RepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Create")
	}
}

type mRepositoryMockFindByID struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockFindByIDExpectation
	expectations       []*RepositoryMockFindByIDExpectation

	callArgs []*RepositoryMockFindByIDParams
	mutex    sync.RWMutex
}

// RepositoryMockFindByIDExpectation specifies expectation struct of the Repository.FindByID
type RepositoryMockFindByIDExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockFindByIDParams
	results *RepositoryMockFindByIDResults
	Counter uint64
}

// RepositoryMockFindByIDParams contains parameters of the Repository.FindByID
type RepositoryMockFindByIDParams struct {
	ctx context.Context
	id  int
}

// RepositoryMockFindByIDResults contains results of the Repository.FindByID
type RepositoryMockFindByIDResults struct {
	up1 *URLData
	err error
}

// Expect sets up expected params for Repository.FindByID
func (mmFindByID *mRepositoryMockFindByID) Expect(ctx context.Context, id int) *mRepositoryMockFindByID {
	if mmFindByID.mock.funcFindByID != nil {
		mmFindByID.mock.t.Fatalf("RepositoryMock.FindByID mock is already set by Set")
	}

	if mmFindByID.defaultExpectation == nil {
		mmFindByID.defaultExpectation = &RepositoryMockFindByIDExpectation{}
	}

	mmFindByID.defaultExpectation.params = &RepositoryMockFindByIDParams{ctx, id}
	for _, e := range mmFindByID.expectations {
		if minimock.Equal(e.params, mmFindByID.defaultExpectation.params) {
			mmFindByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindByID.defaultExpectation.params)
		}
	}

	return mmFindByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.FindByID
func (mmFindByID *mRepositoryMockFindByID) Inspect(f func(ctx context.Context, id int)) *mRepositoryMockFindByID {
	if mmFindByID.mock.inspectFuncFindByID != nil {
		mmFindByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.FindByID")
	}

	mmFindByID.mock.inspectFuncFindByID = f

	return mmFindByID
}

// Return sets up results that will be returned by Repository.FindByID
func (mmFindByID *mRepositoryMockFindByID) Return(up1 *URLData, err error) *RepositoryMock {
	if mmFindByID.mock.funcFindByID != nil {
		mmFindByID.mock.t.Fatalf("RepositoryMock.FindByID mock is already set by Set")
	}

	if mmFindByID.defaultExpectation == nil {
		mmFindByID.defaultExpectation = &RepositoryMockFindByIDExpectation{mock: mmFindByID.mock}
	}
	mmFindByID.defaultExpectation.results = &RepositoryMockFindByIDResults{up1, err}
	return mmFindByID.mock
}

//Set uses given function f to mock the Repository.FindByID method
func (mmFindByID *mRepositoryMockFindByID) Set(f func(ctx context.Context, id int) (up1 *URLData, err error)) *RepositoryMock {
	if mmFindByID.defaultExpectation != nil {
		mmFindByID.mock.t.Fatalf("Default expectation is already set for the Repository.FindByID method")
	}

	if len(mmFindByID.expectations) > 0 {
		mmFindByID.mock.t.Fatalf("Some expectations are already set for the Repository.FindByID method")
	}

	mmFindByID.mock.funcFindByID = f
	return mmFindByID.mock
}

// When sets expectation for the Repository.FindByID which will trigger the stat defined by the following
// Then helper
func (mmFindByID *mRepositoryMockFindByID) When(ctx context.Context, id int) *RepositoryMockFindByIDExpectation {
	if mmFindByID.mock.funcFindByID != nil {
		mmFindByID.mock.t.Fatalf("RepositoryMock.FindByID mock is already set by Set")
	}

	expectation := &RepositoryMockFindByIDExpectation{
		mock:   mmFindByID.mock,
		params: &RepositoryMockFindByIDParams{ctx, id},
	}
	mmFindByID.expectations = append(mmFindByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.FindByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockFindByIDExpectation) Then(up1 *URLData, err error) *RepositoryMock {
	e.results = &RepositoryMockFindByIDResults{up1, err}
	return e.mock
}

// FindByID implements Repository
func (mmFindByID *RepositoryMock) FindByID(ctx context.Context, id int) (up1 *URLData, err error) {
	mm_atomic.AddUint64(&mmFindByID.beforeFindByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmFindByID.afterFindByIDCounter, 1)

	if mmFindByID.inspectFuncFindByID != nil {
		mmFindByID.inspectFuncFindByID(ctx, id)
	}

	mm_params := &RepositoryMockFindByIDParams{ctx, id}

	// Record call args
	mmFindByID.FindByIDMock.mutex.Lock()
	mmFindByID.FindByIDMock.callArgs = append(mmFindByID.FindByIDMock.callArgs, mm_params)
	mmFindByID.FindByIDMock.mutex.Unlock()

	for _, e := range mmFindByID.FindByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmFindByID.FindByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindByID.FindByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmFindByID.FindByIDMock.defaultExpectation.params
		mm_got := RepositoryMockFindByIDParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindByID.t.Errorf("RepositoryMock.FindByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindByID.FindByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmFindByID.t.Fatal("No results are set for the RepositoryMock.FindByID")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmFindByID.funcFindByID != nil {
		return mmFindByID.funcFindByID(ctx, id)
	}
	mmFindByID.t.Fatalf("Unexpected call to RepositoryMock.FindByID. %v %v", ctx, id)
	return
}

// FindByIDAfterCounter returns a count of finished RepositoryMock.FindByID invocations
func (mmFindByID *RepositoryMock) FindByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindByID.afterFindByIDCounter)
}

// FindByIDBeforeCounter returns a count of RepositoryMock.FindByID invocations
func (mmFindByID *RepositoryMock) FindByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindByID.beforeFindByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.FindByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindByID *mRepositoryMockFindByID) Calls() []*RepositoryMockFindByIDParams {
	mmFindByID.mutex.RLock()

	argCopy := make([]*RepositoryMockFindByIDParams, len(mmFindByID.callArgs))
	copy(argCopy, mmFindByID.callArgs)

	mmFindByID.mutex.RUnlock()

	return argCopy
}

// MinimockFindByIDDone returns true if the count of the FindByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockFindByIDDone() bool {
	for _, e := range m.FindByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindByID != nil && mm_atomic.LoadUint64(&m.afterFindByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockFindByIDInspect() {
	for _, e := range m.FindByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.FindByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindByIDCounter) < 1 {
		if m.FindByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.FindByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.FindByID with params: %#v", *m.FindByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindByID != nil && mm_atomic.LoadUint64(&m.afterFindByIDCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.FindByID")
	}
}

type mRepositoryMockFindByToken struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockFindByTokenExpectation
	expectations       []*RepositoryMockFindByTokenExpectation

	callArgs []*RepositoryMockFindByTokenParams
	mutex    sync.RWMutex
}

// RepositoryMockFindByTokenExpectation specifies expectation struct of the Repository.FindByToken
type RepositoryMockFindByTokenExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockFindByTokenParams
	results *RepositoryMockFindByTokenResults
	Counter uint64
}

// RepositoryMockFindByTokenParams contains parameters of the Repository.FindByToken
type RepositoryMockFindByTokenParams struct {
	ctx   context.Context
	token string
}

// RepositoryMockFindByTokenResults contains results of the Repository.FindByToken
type RepositoryMockFindByTokenResults struct {
	up1 *URLData
	err error
}

// Expect sets up expected params for Repository.FindByToken
func (mmFindByToken *mRepositoryMockFindByToken) Expect(ctx context.Context, token string) *mRepositoryMockFindByToken {
	if mmFindByToken.mock.funcFindByToken != nil {
		mmFindByToken.mock.t.Fatalf("RepositoryMock.FindByToken mock is already set by Set")
	}

	if mmFindByToken.defaultExpectation == nil {
		mmFindByToken.defaultExpectation = &RepositoryMockFindByTokenExpectation{}
	}

	mmFindByToken.defaultExpectation.params = &RepositoryMockFindByTokenParams{ctx, token}
	for _, e := range mmFindByToken.expectations {
		if minimock.Equal(e.params, mmFindByToken.defaultExpectation.params) {
			mmFindByToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindByToken.defaultExpectation.params)
		}
	}

	return mmFindByToken
}

// Inspect accepts an inspector function that has same arguments as the Repository.FindByToken
func (mmFindByToken *mRepositoryMockFindByToken) Inspect(f func(ctx context.Context, token string)) *mRepositoryMockFindByToken {
	if mmFindByToken.mock.inspectFuncFindByToken != nil {
		mmFindByToken.mock.t.Fatalf("Inspect function is already set for RepositoryMock.FindByToken")
	}

	mmFindByToken.mock.inspectFuncFindByToken = f

	return mmFindByToken
}

// Return sets up results that will be returned by Repository.FindByToken
func (mmFindByToken *mRepositoryMockFindByToken) Return(up1 *URLData, err error) *RepositoryMock {
	if mmFindByToken.mock.funcFindByToken != nil {
		mmFindByToken.mock.t.Fatalf("RepositoryMock.FindByToken mock is already set by Set")
	}

	if mmFindByToken.defaultExpectation == nil {
		mmFindByToken.defaultExpectation = &RepositoryMockFindByTokenExpectation{mock: mmFindByToken.mock}
	}
	mmFindByToken.defaultExpectation.results = &RepositoryMockFindByTokenResults{up1, err}
	return mmFindByToken.mock
}

//Set uses given function f to mock the Repository.FindByToken method
func (mmFindByToken *mRepositoryMockFindByToken) Set(f func(ctx context.Context, token string) (up1 *URLData, err error)) *RepositoryMock {
	if mmFindByToken.defaultExpectation != nil {
		mmFindByToken.mock.t.Fatalf("Default expectation is already set for the Repository.FindByToken method")
	}

	if len(mmFindByToken.expectations) > 0 {
		mmFindByToken.mock.t.Fatalf("Some expectations are already set for the Repository.FindByToken method")
	}

	mmFindByToken.mock.funcFindByToken = f
	return mmFindByToken.mock
}

// When sets expectation for the Repository.FindByToken which will trigger the stat defined by the following
// Then helper
func (mmFindByToken *mRepositoryMockFindByToken) When(ctx context.Context, token string) *RepositoryMockFindByTokenExpectation {
	if mmFindByToken.mock.funcFindByToken != nil {
		mmFindByToken.mock.t.Fatalf("RepositoryMock.FindByToken mock is already set by Set")
	}

	expectation := &RepositoryMockFindByTokenExpectation{
		mock:   mmFindByToken.mock,
		params: &RepositoryMockFindByTokenParams{ctx, token},
	}
	mmFindByToken.expectations = append(mmFindByToken.expectations, expectation)
	return expectation
}

// Then sets up Repository.FindByToken return parameters for the expectation previously defined by the When method
func (e *RepositoryMockFindByTokenExpectation) Then(up1 *URLData, err error) *RepositoryMock {
	e.results = &RepositoryMockFindByTokenResults{up1, err}
	return e.mock
}

// FindByToken implements Repository
func (mmFindByToken *RepositoryMock) FindByToken(ctx context.Context, token string) (up1 *URLData, err error) {
	mm_atomic.AddUint64(&mmFindByToken.beforeFindByTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmFindByToken.afterFindByTokenCounter, 1)

	if mmFindByToken.inspectFuncFindByToken != nil {
		mmFindByToken.inspectFuncFindByToken(ctx, token)
	}

	mm_params := &RepositoryMockFindByTokenParams{ctx, token}

	// Record call args
	mmFindByToken.FindByTokenMock.mutex.Lock()
	mmFindByToken.FindByTokenMock.callArgs = append(mmFindByToken.FindByTokenMock.callArgs, mm_params)
	mmFindByToken.FindByTokenMock.mutex.Unlock()

	for _, e := range mmFindByToken.FindByTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmFindByToken.FindByTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindByToken.FindByTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmFindByToken.FindByTokenMock.defaultExpectation.params
		mm_got := RepositoryMockFindByTokenParams{ctx, token}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindByToken.t.Errorf("RepositoryMock.FindByToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindByToken.FindByTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmFindByToken.t.Fatal("No results are set for the RepositoryMock.FindByToken")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmFindByToken.funcFindByToken != nil {
		return mmFindByToken.funcFindByToken(ctx, token)
	}
	mmFindByToken.t.Fatalf("Unexpected call to RepositoryMock.FindByToken. %v %v", ctx, token)
	return
}

// FindByTokenAfterCounter returns a count of finished RepositoryMock.FindByToken invocations
func (mmFindByToken *RepositoryMock) FindByTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindByToken.afterFindByTokenCounter)
}

// FindByTokenBeforeCounter returns a count of RepositoryMock.FindByToken invocations
func (mmFindByToken *RepositoryMock) FindByTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindByToken.beforeFindByTokenCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.FindByToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindByToken *mRepositoryMockFindByToken) Calls() []*RepositoryMockFindByTokenParams {
	mmFindByToken.mutex.RLock()

	argCopy := make([]*RepositoryMockFindByTokenParams, len(mmFindByToken.callArgs))
	copy(argCopy, mmFindByToken.callArgs)

	mmFindByToken.mutex.RUnlock()

	return argCopy
}

// MinimockFindByTokenDone returns true if the count of the FindByToken invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockFindByTokenDone() bool {
	for _, e := range m.FindByTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindByTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindByTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindByToken != nil && mm_atomic.LoadUint64(&m.afterFindByTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindByTokenInspect logs each unmet expectation
func (m *RepositoryMock) MinimockFindByTokenInspect() {
	for _, e := range m.FindByTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.FindByToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindByTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindByTokenCounter) < 1 {
		if m.FindByTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.FindByToken")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.FindByToken with params: %#v", *m.FindByTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindByToken != nil && mm_atomic.LoadUint64(&m.afterFindByTokenCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.FindByToken")
	}
}

type mRepositoryMockUpdateCounter struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateCounterExpectation
	expectations       []*RepositoryMockUpdateCounterExpectation

	callArgs []*RepositoryMockUpdateCounterParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateCounterExpectation specifies expectation struct of the Repository.UpdateCounter
type RepositoryMockUpdateCounterExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateCounterParams
	results *RepositoryMockUpdateCounterResults
	Counter uint64
}

// RepositoryMockUpdateCounterParams contains parameters of the Repository.UpdateCounter
type RepositoryMockUpdateCounterParams struct {
	ctx      context.Context
	counter  int64
	shortURL string
}

// RepositoryMockUpdateCounterResults contains results of the Repository.UpdateCounter
type RepositoryMockUpdateCounterResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateCounter
func (mmUpdateCounter *mRepositoryMockUpdateCounter) Expect(ctx context.Context, counter int64, shortURL string) *mRepositoryMockUpdateCounter {
	if mmUpdateCounter.mock.funcUpdateCounter != nil {
		mmUpdateCounter.mock.t.Fatalf("RepositoryMock.UpdateCounter mock is already set by Set")
	}

	if mmUpdateCounter.defaultExpectation == nil {
		mmUpdateCounter.defaultExpectation = &RepositoryMockUpdateCounterExpectation{}
	}

	mmUpdateCounter.defaultExpectation.params = &RepositoryMockUpdateCounterParams{ctx, counter, shortURL}
	for _, e := range mmUpdateCounter.expectations {
		if minimock.Equal(e.params, mmUpdateCounter.defaultExpectation.params) {
			mmUpdateCounter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCounter.defaultExpectation.params)
		}
	}

	return mmUpdateCounter
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateCounter
func (mmUpdateCounter *mRepositoryMockUpdateCounter) Inspect(f func(ctx context.Context, counter int64, shortURL string)) *mRepositoryMockUpdateCounter {
	if mmUpdateCounter.mock.inspectFuncUpdateCounter != nil {
		mmUpdateCounter.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateCounter")
	}

	mmUpdateCounter.mock.inspectFuncUpdateCounter = f

	return mmUpdateCounter
}

// Return sets up results that will be returned by Repository.UpdateCounter
func (mmUpdateCounter *mRepositoryMockUpdateCounter) Return(err error) *RepositoryMock {
	if mmUpdateCounter.mock.funcUpdateCounter != nil {
		mmUpdateCounter.mock.t.Fatalf("RepositoryMock.UpdateCounter mock is already set by Set")
	}

	if mmUpdateCounter.defaultExpectation == nil {
		mmUpdateCounter.defaultExpectation = &RepositoryMockUpdateCounterExpectation{mock: mmUpdateCounter.mock}
	}
	mmUpdateCounter.defaultExpectation.results = &RepositoryMockUpdateCounterResults{err}
	return mmUpdateCounter.mock
}

//Set uses given function f to mock the Repository.UpdateCounter method
func (mmUpdateCounter *mRepositoryMockUpdateCounter) Set(f func(ctx context.Context, counter int64, shortURL string) (err error)) *RepositoryMock {
	if mmUpdateCounter.defaultExpectation != nil {
		mmUpdateCounter.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateCounter method")
	}

	if len(mmUpdateCounter.expectations) > 0 {
		mmUpdateCounter.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateCounter method")
	}

	mmUpdateCounter.mock.funcUpdateCounter = f
	return mmUpdateCounter.mock
}

// When sets expectation for the Repository.UpdateCounter which will trigger the stat defined by the following
// Then helper
func (mmUpdateCounter *mRepositoryMockUpdateCounter) When(ctx context.Context, counter int64, shortURL string) *RepositoryMockUpdateCounterExpectation {
	if mmUpdateCounter.mock.funcUpdateCounter != nil {
		mmUpdateCounter.mock.t.Fatalf("RepositoryMock.UpdateCounter mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateCounterExpectation{
		mock:   mmUpdateCounter.mock,
		params: &RepositoryMockUpdateCounterParams{ctx, counter, shortURL},
	}
	mmUpdateCounter.expectations = append(mmUpdateCounter.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateCounter return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateCounterExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateCounterResults{err}
	return e.mock
}

// UpdateCounter implements Repository
func (mmUpdateCounter *RepositoryMock) UpdateCounter(ctx context.Context, counter int64, shortURL string) (err error) {
	mm_atomic.AddUint64(&mmUpdateCounter.beforeUpdateCounterCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCounter.afterUpdateCounterCounter, 1)

	if mmUpdateCounter.inspectFuncUpdateCounter != nil {
		mmUpdateCounter.inspectFuncUpdateCounter(ctx, counter, shortURL)
	}

	mm_params := &RepositoryMockUpdateCounterParams{ctx, counter, shortURL}

	// Record call args
	mmUpdateCounter.UpdateCounterMock.mutex.Lock()
	mmUpdateCounter.UpdateCounterMock.callArgs = append(mmUpdateCounter.UpdateCounterMock.callArgs, mm_params)
	mmUpdateCounter.UpdateCounterMock.mutex.Unlock()

	for _, e := range mmUpdateCounter.UpdateCounterMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateCounter.UpdateCounterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCounter.UpdateCounterMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCounter.UpdateCounterMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateCounterParams{ctx, counter, shortURL}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCounter.t.Errorf("RepositoryMock.UpdateCounter got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCounter.UpdateCounterMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCounter.t.Fatal("No results are set for the RepositoryMock.UpdateCounter")
		}
		return (*mm_results).err
	}
	if mmUpdateCounter.funcUpdateCounter != nil {
		return mmUpdateCounter.funcUpdateCounter(ctx, counter, shortURL)
	}
	mmUpdateCounter.t.Fatalf("Unexpected call to RepositoryMock.UpdateCounter. %v %v %v", ctx, counter, shortURL)
	return
}

// UpdateCounterAfterCounter returns a count of finished RepositoryMock.UpdateCounter invocations
func (mmUpdateCounter *RepositoryMock) UpdateCounterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCounter.afterUpdateCounterCounter)
}

// UpdateCounterBeforeCounter returns a count of RepositoryMock.UpdateCounter invocations
func (mmUpdateCounter *RepositoryMock) UpdateCounterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCounter.beforeUpdateCounterCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateCounter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCounter *mRepositoryMockUpdateCounter) Calls() []*RepositoryMockUpdateCounterParams {
	mmUpdateCounter.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateCounterParams, len(mmUpdateCounter.callArgs))
	copy(argCopy, mmUpdateCounter.callArgs)

	mmUpdateCounter.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCounterDone returns true if the count of the UpdateCounter invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateCounterDone() bool {
	for _, e := range m.UpdateCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCounterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCounter != nil && mm_atomic.LoadUint64(&m.afterUpdateCounterCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateCounterInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateCounterInspect() {
	for _, e := range m.UpdateCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateCounter with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCounterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounterCounter) < 1 {
		if m.UpdateCounterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateCounter")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateCounter with params: %#v", *m.UpdateCounterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCounter != nil && mm_atomic.LoadUint64(&m.afterUpdateCounterCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateCounter")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockFindByIDInspect()

		m.MinimockFindByTokenInspect()

		m.MinimockUpdateCounterInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockFindByIDDone() &&
		m.MinimockFindByTokenDone() &&
		m.MinimockUpdateCounterDone()
}
