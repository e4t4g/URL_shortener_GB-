package ginrouter

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/e4t4g/URL_shortener_GB-/internal/app/delivery/ginrouter.Delivery -o ./delivery_mock_test.go -n DeliveryMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gin-gonic/gin"
	"github.com/gojuno/minimock/v3"
)

// DeliveryMock implements Delivery
type DeliveryMock struct {
	t minimock.Tester

	funcCreate          func() (h1 gin.HandlerFunc)
	inspectFuncCreate   func()
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mDeliveryMockCreate

	funcGetStat          func() (h1 gin.HandlerFunc)
	inspectFuncGetStat   func()
	afterGetStatCounter  uint64
	beforeGetStatCounter uint64
	GetStatMock          mDeliveryMockGetStat

	funcRedirect          func() (h1 gin.HandlerFunc)
	inspectFuncRedirect   func()
	afterRedirectCounter  uint64
	beforeRedirectCounter uint64
	RedirectMock          mDeliveryMockRedirect

	funcWebGenerate          func() (h1 gin.HandlerFunc)
	inspectFuncWebGenerate   func()
	afterWebGenerateCounter  uint64
	beforeWebGenerateCounter uint64
	WebGenerateMock          mDeliveryMockWebGenerate
}

// NewDeliveryMock returns a mock for Delivery
func NewDeliveryMock(t minimock.Tester) *DeliveryMock {
	m := &DeliveryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mDeliveryMockCreate{mock: m}

	m.GetStatMock = mDeliveryMockGetStat{mock: m}

	m.RedirectMock = mDeliveryMockRedirect{mock: m}

	m.WebGenerateMock = mDeliveryMockWebGenerate{mock: m}

	return m
}

type mDeliveryMockCreate struct {
	mock               *DeliveryMock
	defaultExpectation *DeliveryMockCreateExpectation
	expectations       []*DeliveryMockCreateExpectation
}

// DeliveryMockCreateExpectation specifies expectation struct of the Delivery.Create
type DeliveryMockCreateExpectation struct {
	mock *DeliveryMock

	results *DeliveryMockCreateResults
	Counter uint64
}

// DeliveryMockCreateResults contains results of the Delivery.Create
type DeliveryMockCreateResults struct {
	h1 gin.HandlerFunc
}

// Expect sets up expected params for Delivery.Create
func (mmCreate *mDeliveryMockCreate) Expect() *mDeliveryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DeliveryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DeliveryMockCreateExpectation{}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Delivery.Create
func (mmCreate *mDeliveryMockCreate) Inspect(f func()) *mDeliveryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for DeliveryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Delivery.Create
func (mmCreate *mDeliveryMockCreate) Return(h1 gin.HandlerFunc) *DeliveryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DeliveryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DeliveryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &DeliveryMockCreateResults{h1}
	return mmCreate.mock
}

//Set uses given function f to mock the Delivery.Create method
func (mmCreate *mDeliveryMockCreate) Set(f func() (h1 gin.HandlerFunc)) *DeliveryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Delivery.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Delivery.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// Create implements Delivery
func (mmCreate *DeliveryMock) Create() (h1 gin.HandlerFunc) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate()
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the DeliveryMock.Create")
		}
		return (*mm_results).h1
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate()
	}
	mmCreate.t.Fatalf("Unexpected call to DeliveryMock.Create.")
	return
}

// CreateAfterCounter returns a count of finished DeliveryMock.Create invocations
func (mmCreate *DeliveryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of DeliveryMock.Create invocations
func (mmCreate *DeliveryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *DeliveryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *DeliveryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DeliveryMock.Create")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to DeliveryMock.Create")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to DeliveryMock.Create")
	}
}

type mDeliveryMockGetStat struct {
	mock               *DeliveryMock
	defaultExpectation *DeliveryMockGetStatExpectation
	expectations       []*DeliveryMockGetStatExpectation
}

// DeliveryMockGetStatExpectation specifies expectation struct of the Delivery.GetStat
type DeliveryMockGetStatExpectation struct {
	mock *DeliveryMock

	results *DeliveryMockGetStatResults
	Counter uint64
}

// DeliveryMockGetStatResults contains results of the Delivery.GetStat
type DeliveryMockGetStatResults struct {
	h1 gin.HandlerFunc
}

// Expect sets up expected params for Delivery.GetStat
func (mmGetStat *mDeliveryMockGetStat) Expect() *mDeliveryMockGetStat {
	if mmGetStat.mock.funcGetStat != nil {
		mmGetStat.mock.t.Fatalf("DeliveryMock.GetStat mock is already set by Set")
	}

	if mmGetStat.defaultExpectation == nil {
		mmGetStat.defaultExpectation = &DeliveryMockGetStatExpectation{}
	}

	return mmGetStat
}

// Inspect accepts an inspector function that has same arguments as the Delivery.GetStat
func (mmGetStat *mDeliveryMockGetStat) Inspect(f func()) *mDeliveryMockGetStat {
	if mmGetStat.mock.inspectFuncGetStat != nil {
		mmGetStat.mock.t.Fatalf("Inspect function is already set for DeliveryMock.GetStat")
	}

	mmGetStat.mock.inspectFuncGetStat = f

	return mmGetStat
}

// Return sets up results that will be returned by Delivery.GetStat
func (mmGetStat *mDeliveryMockGetStat) Return(h1 gin.HandlerFunc) *DeliveryMock {
	if mmGetStat.mock.funcGetStat != nil {
		mmGetStat.mock.t.Fatalf("DeliveryMock.GetStat mock is already set by Set")
	}

	if mmGetStat.defaultExpectation == nil {
		mmGetStat.defaultExpectation = &DeliveryMockGetStatExpectation{mock: mmGetStat.mock}
	}
	mmGetStat.defaultExpectation.results = &DeliveryMockGetStatResults{h1}
	return mmGetStat.mock
}

//Set uses given function f to mock the Delivery.GetStat method
func (mmGetStat *mDeliveryMockGetStat) Set(f func() (h1 gin.HandlerFunc)) *DeliveryMock {
	if mmGetStat.defaultExpectation != nil {
		mmGetStat.mock.t.Fatalf("Default expectation is already set for the Delivery.GetStat method")
	}

	if len(mmGetStat.expectations) > 0 {
		mmGetStat.mock.t.Fatalf("Some expectations are already set for the Delivery.GetStat method")
	}

	mmGetStat.mock.funcGetStat = f
	return mmGetStat.mock
}

// GetStat implements Delivery
func (mmGetStat *DeliveryMock) GetStat() (h1 gin.HandlerFunc) {
	mm_atomic.AddUint64(&mmGetStat.beforeGetStatCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStat.afterGetStatCounter, 1)

	if mmGetStat.inspectFuncGetStat != nil {
		mmGetStat.inspectFuncGetStat()
	}

	if mmGetStat.GetStatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStat.GetStatMock.defaultExpectation.Counter, 1)

		mm_results := mmGetStat.GetStatMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStat.t.Fatal("No results are set for the DeliveryMock.GetStat")
		}
		return (*mm_results).h1
	}
	if mmGetStat.funcGetStat != nil {
		return mmGetStat.funcGetStat()
	}
	mmGetStat.t.Fatalf("Unexpected call to DeliveryMock.GetStat.")
	return
}

// GetStatAfterCounter returns a count of finished DeliveryMock.GetStat invocations
func (mmGetStat *DeliveryMock) GetStatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStat.afterGetStatCounter)
}

// GetStatBeforeCounter returns a count of DeliveryMock.GetStat invocations
func (mmGetStat *DeliveryMock) GetStatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStat.beforeGetStatCounter)
}

// MinimockGetStatDone returns true if the count of the GetStat invocations corresponds
// the number of defined expectations
func (m *DeliveryMock) MinimockGetStatDone() bool {
	for _, e := range m.GetStatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStat != nil && mm_atomic.LoadUint64(&m.afterGetStatCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStatInspect logs each unmet expectation
func (m *DeliveryMock) MinimockGetStatInspect() {
	for _, e := range m.GetStatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DeliveryMock.GetStat")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStatCounter) < 1 {
		m.t.Error("Expected call to DeliveryMock.GetStat")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStat != nil && mm_atomic.LoadUint64(&m.afterGetStatCounter) < 1 {
		m.t.Error("Expected call to DeliveryMock.GetStat")
	}
}

type mDeliveryMockRedirect struct {
	mock               *DeliveryMock
	defaultExpectation *DeliveryMockRedirectExpectation
	expectations       []*DeliveryMockRedirectExpectation
}

// DeliveryMockRedirectExpectation specifies expectation struct of the Delivery.Redirect
type DeliveryMockRedirectExpectation struct {
	mock *DeliveryMock

	results *DeliveryMockRedirectResults
	Counter uint64
}

// DeliveryMockRedirectResults contains results of the Delivery.Redirect
type DeliveryMockRedirectResults struct {
	h1 gin.HandlerFunc
}

// Expect sets up expected params for Delivery.Redirect
func (mmRedirect *mDeliveryMockRedirect) Expect() *mDeliveryMockRedirect {
	if mmRedirect.mock.funcRedirect != nil {
		mmRedirect.mock.t.Fatalf("DeliveryMock.Redirect mock is already set by Set")
	}

	if mmRedirect.defaultExpectation == nil {
		mmRedirect.defaultExpectation = &DeliveryMockRedirectExpectation{}
	}

	return mmRedirect
}

// Inspect accepts an inspector function that has same arguments as the Delivery.Redirect
func (mmRedirect *mDeliveryMockRedirect) Inspect(f func()) *mDeliveryMockRedirect {
	if mmRedirect.mock.inspectFuncRedirect != nil {
		mmRedirect.mock.t.Fatalf("Inspect function is already set for DeliveryMock.Redirect")
	}

	mmRedirect.mock.inspectFuncRedirect = f

	return mmRedirect
}

// Return sets up results that will be returned by Delivery.Redirect
func (mmRedirect *mDeliveryMockRedirect) Return(h1 gin.HandlerFunc) *DeliveryMock {
	if mmRedirect.mock.funcRedirect != nil {
		mmRedirect.mock.t.Fatalf("DeliveryMock.Redirect mock is already set by Set")
	}

	if mmRedirect.defaultExpectation == nil {
		mmRedirect.defaultExpectation = &DeliveryMockRedirectExpectation{mock: mmRedirect.mock}
	}
	mmRedirect.defaultExpectation.results = &DeliveryMockRedirectResults{h1}
	return mmRedirect.mock
}

//Set uses given function f to mock the Delivery.Redirect method
func (mmRedirect *mDeliveryMockRedirect) Set(f func() (h1 gin.HandlerFunc)) *DeliveryMock {
	if mmRedirect.defaultExpectation != nil {
		mmRedirect.mock.t.Fatalf("Default expectation is already set for the Delivery.Redirect method")
	}

	if len(mmRedirect.expectations) > 0 {
		mmRedirect.mock.t.Fatalf("Some expectations are already set for the Delivery.Redirect method")
	}

	mmRedirect.mock.funcRedirect = f
	return mmRedirect.mock
}

// Redirect implements Delivery
func (mmRedirect *DeliveryMock) Redirect() (h1 gin.HandlerFunc) {
	mm_atomic.AddUint64(&mmRedirect.beforeRedirectCounter, 1)
	defer mm_atomic.AddUint64(&mmRedirect.afterRedirectCounter, 1)

	if mmRedirect.inspectFuncRedirect != nil {
		mmRedirect.inspectFuncRedirect()
	}

	if mmRedirect.RedirectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRedirect.RedirectMock.defaultExpectation.Counter, 1)

		mm_results := mmRedirect.RedirectMock.defaultExpectation.results
		if mm_results == nil {
			mmRedirect.t.Fatal("No results are set for the DeliveryMock.Redirect")
		}
		return (*mm_results).h1
	}
	if mmRedirect.funcRedirect != nil {
		return mmRedirect.funcRedirect()
	}
	mmRedirect.t.Fatalf("Unexpected call to DeliveryMock.Redirect.")
	return
}

// RedirectAfterCounter returns a count of finished DeliveryMock.Redirect invocations
func (mmRedirect *DeliveryMock) RedirectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRedirect.afterRedirectCounter)
}

// RedirectBeforeCounter returns a count of DeliveryMock.Redirect invocations
func (mmRedirect *DeliveryMock) RedirectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRedirect.beforeRedirectCounter)
}

// MinimockRedirectDone returns true if the count of the Redirect invocations corresponds
// the number of defined expectations
func (m *DeliveryMock) MinimockRedirectDone() bool {
	for _, e := range m.RedirectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RedirectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRedirectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRedirect != nil && mm_atomic.LoadUint64(&m.afterRedirectCounter) < 1 {
		return false
	}
	return true
}

// MinimockRedirectInspect logs each unmet expectation
func (m *DeliveryMock) MinimockRedirectInspect() {
	for _, e := range m.RedirectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DeliveryMock.Redirect")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RedirectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRedirectCounter) < 1 {
		m.t.Error("Expected call to DeliveryMock.Redirect")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRedirect != nil && mm_atomic.LoadUint64(&m.afterRedirectCounter) < 1 {
		m.t.Error("Expected call to DeliveryMock.Redirect")
	}
}

type mDeliveryMockWebGenerate struct {
	mock               *DeliveryMock
	defaultExpectation *DeliveryMockWebGenerateExpectation
	expectations       []*DeliveryMockWebGenerateExpectation
}

// DeliveryMockWebGenerateExpectation specifies expectation struct of the Delivery.WebGenerate
type DeliveryMockWebGenerateExpectation struct {
	mock *DeliveryMock

	results *DeliveryMockWebGenerateResults
	Counter uint64
}

// DeliveryMockWebGenerateResults contains results of the Delivery.WebGenerate
type DeliveryMockWebGenerateResults struct {
	h1 gin.HandlerFunc
}

// Expect sets up expected params for Delivery.WebGenerate
func (mmWebGenerate *mDeliveryMockWebGenerate) Expect() *mDeliveryMockWebGenerate {
	if mmWebGenerate.mock.funcWebGenerate != nil {
		mmWebGenerate.mock.t.Fatalf("DeliveryMock.WebGenerate mock is already set by Set")
	}

	if mmWebGenerate.defaultExpectation == nil {
		mmWebGenerate.defaultExpectation = &DeliveryMockWebGenerateExpectation{}
	}

	return mmWebGenerate
}

// Inspect accepts an inspector function that has same arguments as the Delivery.WebGenerate
func (mmWebGenerate *mDeliveryMockWebGenerate) Inspect(f func()) *mDeliveryMockWebGenerate {
	if mmWebGenerate.mock.inspectFuncWebGenerate != nil {
		mmWebGenerate.mock.t.Fatalf("Inspect function is already set for DeliveryMock.WebGenerate")
	}

	mmWebGenerate.mock.inspectFuncWebGenerate = f

	return mmWebGenerate
}

// Return sets up results that will be returned by Delivery.WebGenerate
func (mmWebGenerate *mDeliveryMockWebGenerate) Return(h1 gin.HandlerFunc) *DeliveryMock {
	if mmWebGenerate.mock.funcWebGenerate != nil {
		mmWebGenerate.mock.t.Fatalf("DeliveryMock.WebGenerate mock is already set by Set")
	}

	if mmWebGenerate.defaultExpectation == nil {
		mmWebGenerate.defaultExpectation = &DeliveryMockWebGenerateExpectation{mock: mmWebGenerate.mock}
	}
	mmWebGenerate.defaultExpectation.results = &DeliveryMockWebGenerateResults{h1}
	return mmWebGenerate.mock
}

//Set uses given function f to mock the Delivery.WebGenerate method
func (mmWebGenerate *mDeliveryMockWebGenerate) Set(f func() (h1 gin.HandlerFunc)) *DeliveryMock {
	if mmWebGenerate.defaultExpectation != nil {
		mmWebGenerate.mock.t.Fatalf("Default expectation is already set for the Delivery.WebGenerate method")
	}

	if len(mmWebGenerate.expectations) > 0 {
		mmWebGenerate.mock.t.Fatalf("Some expectations are already set for the Delivery.WebGenerate method")
	}

	mmWebGenerate.mock.funcWebGenerate = f
	return mmWebGenerate.mock
}

// WebGenerate implements Delivery
func (mmWebGenerate *DeliveryMock) WebGenerate() (h1 gin.HandlerFunc) {
	mm_atomic.AddUint64(&mmWebGenerate.beforeWebGenerateCounter, 1)
	defer mm_atomic.AddUint64(&mmWebGenerate.afterWebGenerateCounter, 1)

	if mmWebGenerate.inspectFuncWebGenerate != nil {
		mmWebGenerate.inspectFuncWebGenerate()
	}

	if mmWebGenerate.WebGenerateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWebGenerate.WebGenerateMock.defaultExpectation.Counter, 1)

		mm_results := mmWebGenerate.WebGenerateMock.defaultExpectation.results
		if mm_results == nil {
			mmWebGenerate.t.Fatal("No results are set for the DeliveryMock.WebGenerate")
		}
		return (*mm_results).h1
	}
	if mmWebGenerate.funcWebGenerate != nil {
		return mmWebGenerate.funcWebGenerate()
	}
	mmWebGenerate.t.Fatalf("Unexpected call to DeliveryMock.WebGenerate.")
	return
}

// WebGenerateAfterCounter returns a count of finished DeliveryMock.WebGenerate invocations
func (mmWebGenerate *DeliveryMock) WebGenerateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWebGenerate.afterWebGenerateCounter)
}

// WebGenerateBeforeCounter returns a count of DeliveryMock.WebGenerate invocations
func (mmWebGenerate *DeliveryMock) WebGenerateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWebGenerate.beforeWebGenerateCounter)
}

// MinimockWebGenerateDone returns true if the count of the WebGenerate invocations corresponds
// the number of defined expectations
func (m *DeliveryMock) MinimockWebGenerateDone() bool {
	for _, e := range m.WebGenerateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WebGenerateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWebGenerateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWebGenerate != nil && mm_atomic.LoadUint64(&m.afterWebGenerateCounter) < 1 {
		return false
	}
	return true
}

// MinimockWebGenerateInspect logs each unmet expectation
func (m *DeliveryMock) MinimockWebGenerateInspect() {
	for _, e := range m.WebGenerateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DeliveryMock.WebGenerate")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WebGenerateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWebGenerateCounter) < 1 {
		m.t.Error("Expected call to DeliveryMock.WebGenerate")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWebGenerate != nil && mm_atomic.LoadUint64(&m.afterWebGenerateCounter) < 1 {
		m.t.Error("Expected call to DeliveryMock.WebGenerate")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DeliveryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockGetStatInspect()

		m.MinimockRedirectInspect()

		m.MinimockWebGenerateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DeliveryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DeliveryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetStatDone() &&
		m.MinimockRedirectDone() &&
		m.MinimockWebGenerateDone()
}
